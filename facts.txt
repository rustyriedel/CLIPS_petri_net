(deftemplate fact
	(slot x
	(type SYMBOL))
	(slot status
	(type INTEGER))
)

(deffacts startup
	(fact (x A) (status 1))
	(fact (x B) (status 1))
	(fact (x C) (status 1))
	(fact (x p1) (status 0))
	(fact (x p2) (status 0))
	(fact (x p3) (status 0))
	(fact (x p4) (status 0))
	(fact (x p5) (status 0))
	(fact (x p6) (status 0))
	(fact (x p7) (status 0))
	(fact (x p8) (status 0))
	(fact (x p9) (status 0))
	(fact (x p10) (status 0))
	(fact (x clk) (status 0))
	(fact (x first) (status 1))
)

(defrule print
	(and (fact (x clk) (status 0)) (fact (x first) (status 0)))
	?f1 <- (fact (x p1) (status ?p1))
	?f2 <- (fact (x p2) (status ?p2))
	?f3 <- (fact (x p3) (status ?p3))
	?f4 <- (fact (x p4) (status ?p4))
	?f5 <- (fact (x p5) (status ?p5))
	?f6 <- (fact (x p6) (status ?p6))
	?f7 <- (fact (x p7) (status ?p7))
	?f8 <- (fact (x p8) (status ?p8))
	?f9 <- (fact (x p9) (status ?p9))
	?f10 <- (fact (x p10) (status ?p10))
	=>
	(printout output ?p1 ",")
	(printout output ?p2 ",")
	(printout output ?p3 ",")
	(printout output ?p4 ",")
	(printout output ?p5 ",")
	(printout output ?p6 ",")
	(printout output ?p7 ",")
	(printout output ?p8 ",")
	(printout output ?p9 ",")
	(printout output ?p10 crlf)
)

(defrule upkeep
	?clk <- (fact (x clk) (status 0))	;bind facts to variables
	?f <- (fact (x first) (status ?m))
	?fA <- (fact (x A) (status ?a))
	?fB <- (fact (x B) (status ?b))
	?fC <- (fact (x C) (status ?c))
	?f4 <- (fact (x p4) (status ?p4))
	?f7 <- (fact (x p7) (status ?p7))
	?f10 <- (fact (x p10) (status ?p10))
	=>
	(if (= ?m 1) then (modify ?f (status 0)))	;set first to 0 after 1st run.
	(if (= ?p4 1) then (modify ?f4 (status 0)))	;remove end states (p4, p7, p10)
	(if (= ?p7 1) then (modify ?f7 (status 0)))	;on the next cycle after they are set
	(if (= ?p10 1) then (modify ?f10 (status 0)))

	(bind ?reqX (read data))	;read data from input file
	(bind ?reqY (read data))
	(bind ?reqZ (read data))

	(if (and (= ?reqX 1) (= ?a 1) (= ?b 1)) then	;determine if a request
		(assert (fact (x reqX) (status 1))))		;should be added
	(if (and (= ?reqX 0) (= ?reqY 1) (= ?b 1) (= ?c 1)) then 
		(assert (fact (x reqY) (status 1))))
	(if (and (= ?reqX 0) (= ?reqY 0) (= ?reqZ 1) (= ?c 1)) then 
		(assert (fact (x reqZ) (status 1))))
	(if (and (= ?reqX -1) (= ?reqY -1) (= ?reqZ -1)) then
			(assert (fact (x end) (status 1)))			;end simulation
			(modify ?f (status 1)))
		else
			(modify ?clk (status 1))	;start the clock pulse
)

;--------------------------------
; Rules for making product X
;--------------------------------
(defrule t1
	(and (fact (x reqX) (status 1)) (fact (x A) (status 1)) (fact (x B) (status 1)) (fact (x clk) (status 1)))
	?fA <- (fact (x A) (status 1))
	?fB <- (fact (x B) (status 1))
	?fx <- (fact (x reqX) (status 1))
	?fy <- (fact (x p1) (status 0))
	?clk <- (fact (x clk) (status 1))
	=>
	(modify ?fA (status 0))
	(modify ?fB (status 0))
	(retract ?fx)
	(modify ?fy (status 1))
	(modify ?clk (status 0))
)

(defrule t2
	(and   (fact (x p1) (status 1)) (fact (x clk) (status 1)))
	?fx <- (fact (x p1) (status 1))
	?fy <- (fact (x p2) (status 0))
	?clk <- (fact (x clk) (status 1))
	=>
	(modify ?fx (status 0))
	(modify ?fy (status 1))
	(modify ?clk (status 0))
)

(defrule t3
	(and   (fact (x p2) (status 1)) (fact (x clk) (status 1)))
	?fx <- (fact (x p2) (status 1))
	?fy <- (fact (x p3) (status 0))
	?clk <- (fact (x clk) (status 1))
	=>
	(modify ?fx (status 0))
	(modify ?fy (status 1))
	(modify ?clk (status 0))
)

(defrule t4
	(and (fact (x p3) (status 1)) (fact (x clk) (status 1)))
	?fA <- (fact (x A) (status 0))
	?fB <- (fact (x B) (status 0))
	?fx <- (fact (x p3) (status 1))
	?fy <- (fact (x p4) (status 0))
	?clk <- (fact (x clk) (status 1))
	=>
	(modify ?fA (status 1))
	(modify ?fB (status 1))
	(modify ?fx (status 0))
	(modify ?fy (status 1))
	(modify ?clk (status 0))
	(assert (X))
)

;--------------------------------
; Rules for making product Y
;--------------------------------
(defrule t5
	(and (fact (x reqY) (status 1)) (fact (x B) (status 1)) (fact (x C) (status 1)) (fact (x clk) (status 1)))
	?fB <- (fact (x B) (status 1))
	?fC <- (fact (x C) (status 1))
	?fx <- (fact (x reqY) (status 1))
	?fy <- (fact (x p5) (status 0))
	?clk <- (fact (x clk) (status 1))
	=>
	(modify ?fB (status 0))
	(modify ?fC (status 0))
	(retract ?fx)
	(modify ?fy (status 1))
	(modify ?clk (status 0))
)

(defrule t6
	(and (fact (x p5) (status 1)) (fact (x clk) (status 1)))
	?fx <- (fact (x p5) (status 1))
	?fy <- (fact (x p6) (status 0))
	?clk <- (fact (x clk) (status 1))
	=>
	(modify ?fx (status 0))
	(modify ?fy (status 1))
	(modify ?clk (status 0))
)

(defrule t7
	(and (fact (x p6) (status 1)) (fact (x clk) (status 1)))
	?fB <- (fact (x B) (status 0))
	?fC <- (fact (x C) (status 0))
	?fx <- (fact (x p6) (status 1))
	?fy <- (fact (x p7) (status 0))
	?clk <- (fact (x clk) (status 1))
	=>
	(modify ?fB (status 1))
	(modify ?fC (status 1))
	(modify ?fx (status 0))
	(modify ?fy (status 1))
	(modify ?clk (status 0))
	(assert (Y))
)

;--------------------------------
; Rules for making product Z
;--------------------------------
(defrule t8
	(and (fact (x reqZ) (status 1)) (fact (x C) (status 1)) (fact (x clk) (status 1)))
	?fC <- (fact (x C) (status 1))
	?fx <- (fact (x reqZ) (status 1))
	?fy <- (fact (x p8) (status 0))
	?clk <- (fact (x clk) (status 1))
	=>
	(modify ?fC (status 0))
	(retract ?fx)
	(modify ?fy (status 1))
	(modify ?clk (status 0))
)

(defrule t9
	(and (fact (x p8) (status 1)) (fact (x clk) (status 1)))
	?fx <- (fact (x p8) (status 1))
	?fy <- (fact (x p9) (status 0))
	?clk <- (fact (x clk) (status 1))
	=>
	(modify ?fx (status 0))
	(modify ?fy (status 1))
	(modify ?clk (status 0))
)

(defrule t10
	(and (fact (x p9) (status 1)) (fact (x clk) (status 1)))
	?fC <- (fact (x C) (status 0))
	?fx <- (fact (x p9) (status 1))
	?fy <- (fact (x p10) (status 0))
	?clk <- (fact (x clk) (status 1))
	=>
	(modify ?fC (status 1))
	(modify ?fx (status 0))
	(modify ?fy (status 1))
	(modify ?clk (status 0))
	(assert (Z))
)

(defrule endclk
	(and (fact (x clk) (status 1)) (not (fact (x end) (status 1))))
	?clk <- (fact (x clk) (status 1))
	=>
	(modify ?clk (status 0))
)